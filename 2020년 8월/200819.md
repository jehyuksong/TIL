# 오늘 한 일🔥

- 생활코딩 코딩야학 머신러닝 기초, 중급 코스 5일차를 끝냈다. 중급코스는 마무리되었다!
- 로또 추첨기 만들어달라는 친구한테 로또 추첨기를 만들어줬다. 너무재밌다🤤
- Nodejs, express, API 를 공부했다.

---

# 오늘 느낀 점🔥

- 프로그래밍 쪽을 공부를 해나가다 보면 어느 순간 뭔가의 깨달음을 얻는 순간이 있는 것 같다.
제이쿼리를 배운 뒤에 express가 자바스크립트와 제이쿼리 관계처럼 nodejs와의 관계라는 것을 알게 되었다.
- API를 가져와서 데이터로 불러오는 부분에서 너무 신기했다......뭔가 다양한 것들을 만들 수 있을 것 같은 느낌을 받았다!!!

---

# 생활코딩 코딩야학 [머신러닝] - 기초코스 5일차

# 비지도학습

# 1-19. 군집화(clustering)

- 비슷한 것들을 찾아서 그룹을 만드는 것이다.
- 어떤 대상들을 구분해서 그룹을 만드는 것이 **군집화이고, 어떤 대상이 어떤 그룹에 속하는 지 구분하는 것이 분류이다.**
- 예를 들어 1000만 개의 관측치를 입력하고 100개의 군집이 필요하다고 하면 비슷한 행끼리 묶어서 서로 다른 개체의 수를 가진 군집 100개가 만들어진다.

# 1-20. 연관 규칙 학습(associagtion rule learning)

- '라면을 구매한 사람은 계란을 구매할 확률이 높다. 식빵을 구매한 사람은 우유를 구매할 확률이 높다.' 와 같은 연관성을 표를 통해 찾아낸다. 쇼핑추천,영화추천 등을 만들어 낼 수 있다. 열을 찾아내는 머신러닝의 기법이다. 특성을 그룹핑해준다.

# 1-21. 비지도 학습 정리

- 비지도학습은 탐험적이고, 독립변수와 종속변수의 구분이 중요하지 않다. 
대상의 성질,특성을 파악한다.
데이터를 정리정돈하고 성격을 파악한다.
- 지도학습은 역사적이고, 독립변수와 종속변수가 꼭 필요하다.
역사로부터 결과를 예측한다.

# 1-22. 강화학습(reinforcement learning)

- 경험을 통해 실력을 키워나가는 학습법이고, 상과 벌을 주며 반복하는 것이다.
- 게임(환경)은 게이머(에이전트)에서 현재 상태(상태)를 보여준다. 현재의 점수도 알려주며 상과 벌(보상)을 예측할 수 있고, 게이머는 이에 따라 관찰하고 판단하며 행동(행동)한다. 그 행동을 게임의 변화를 주게 된다. 
이런 과정을 반복하면 게임을 잘해진다. 이런 방법이 **강화학습이라고 한다.**
- 상태(state),보상(reward),환경(evironment),에이전트(agent),정책(policy),행동(action)
즉 강화학습은 특정 환경에서 상태에 따라서 더 많은 보상을 받을 수 있는 행동을 에이전트가 할 수 있도록하는 정책을 만드는 것이 목적이다.

---

# 코딩야학 머신러닝 기초 5일차 느낀 것🔥

- 나중에 인공지능을 직접 사용하거나 협업할 때를 생각해보면 완전 기초중의 기초이지만, 용어나 배경지식에 대해서 알게 된 것 같아서 최소한의 공부로 가성비 좋은 지식을 습득한 것 같다.

---

# 생활코딩 코딩야학 [머신러닝] - 중급코스 5일차

# 2-8. 수업을 마치며

- 스프레드 시트와와 데이터베이스라는 기술을 체계적으로 공부해보면 오렌지를 잘 활용할 수 있다.
- 또한, 통계에 대한 공부를 해보는 것도 좋은 방법이다.
- 분석할 대상과 결과를 보여줄 대상이 없다면 의미가 없다.
- 분석한 정보를 웹페이지로 만들면 모든 사람들에게 보여줄 수 있다. 웹페이지를 공부해봐라.
- 2020년 9월 이후 열릴 머신러닝 1 수업을 들어봐라.
- 오렌지는 GUI기반이고, GUI로 어떤 것을 공부해야하는지 알고, 전체적인 큰 틀을 볼 수 있다.
이러한 경험을 기반으로 코딩,프로그래밍을 공부해서 어렵고 복잡한 것들도 구현해낼 수 있다.
- 머신러닝의 필요성을 느꼈다면 이러한 공부는 즐거운 놀이가 될 것이다.
- 우리는 때로 공부만 하려고 한다. 공부한 것을 사용하는 것은 어렵기 때문이다.
하지만 공부한 것을 사용하지 않고, 공부만 하는 것은 효과적이지 않다.

---

# 코딩야학 머신러닝 중급 5일차 느낀 것🔥

- 코딩야학 머신러닝 중급코스가 모두 끝났다.
많은 것을 배워가지는 않았지만, 다음에 내가 무엇을 해야하고, 팀원이 인공지능을 다룰 때 내가 어떠한 점을 인지하고 있어야 하는 지에 대해서는 기반을 닦은 것 같다.
쉬운 설명과 큰 틀에서 보여주는 수업을 듣게 된 것이 좋은 경험이었다.

---

# Node.js

- 자바스크립트를 브라우저 밖에서 동작하게 한다.

# REPL(Read Evaluation Print Loop)

- 구글 크롬 콘솔에서 코딩을 했던 것과 비슷하다.

### copyFileSync

```jsx
const fs = require("fs");

fs.copyFileSync("file1.txt", "file2.txt");
```

- file2.txt 라는 파일이 없어도 node를 실행시키면 file1과 똑같은 file2가 생성된다.
혹여나 file2가 이미 있고 내용을 가지고 있어도 file1과 같은 내용으로 대체된다.

# NPM

- 노드 패키지 매니저로, 레고로 집을 만든다고 했을 때 나무를 심고 싶으면 나무로 만들어진 트리패키지를 가져와서 심는 것처럼 만들어놓은 다양한 패키지를 사용할 수 있다.

### npm init

- npm 초기화
- npm init을 해서 몇가지 정보를 입력하면 pachage.json이 만들어진다.

### npm

- `npm install superheroes` 로 설치를 한다.
- package.json 에서 dependencies를 보면 추가된 것을 볼 수 있다.

```jsx
let superheroes = require("superheroes");
let superHeroName = superheroes.random();
console.log(superHeroName);
```

- [npmjs.com](http://npmjs.com) 에 보면 다양한 패키지들이 있지만 그 중에서 하나를 사용해보면 슈퍼히어로들의 이름을 랜덤으로 가져오는 패키지를 사용해봤다. 저 상태로 실행을 할 경우 슈퍼히어로들의 이름이 랜덤으로 출력되는 것을 볼 수 있다.

# Express

- jQuery가 javascript를 쉽게 다룰 수 있게끔 도와주는 프레임워크인 것처럼
Express는 node.js를 쉽게 다룰 수 있게끔 도와주는 프레임워크이다.
- Express는 기본적으로 다른 사람이 작성한 코드 묶음으로 추가 기능을 추가하고, 특히 node.js로 빌드된 웹 애플리케이션을 위해 코드를 구성하고 구조화하는데 도움을 준다.
- node.js가 드라이버라면 express는 전동드라이버이다. node.js로도 다 할 수 있지만 반복을 싫어하는 개발자들은 express를 통해서 특정 기능들을 구현한다.

### 서버 연결하기

```jsx
const express = require("express");     // express를 가져온다
const app = express();

app.get("/", function (req, res) {      // 첫번째 값으로 경로를 받고, 2번째 값으로
  res.send("<h1>hello</h1>");           // request,response 매개변수가 있는 함수를 받는다.
});                                     // localhost:3000/   으로 들어가면 뜬다.

app.get("/contact", function (req, res) {
  res.send("jehyuksong@gmail.com");
});                                     // localhost:3000/contact 로 들어가면 뜬다.

app.listen(3000, function () {          // 생성된 서버가 3000포트를 바라보게 하고, 완료되면
  console.log("server started on port 3000..");        // 콜백함수를 실행한다.
});
```

### Nodemon

- `node server.js` 와 같이 사용해서 실행하는 것은 수정할 때 마다 실행취소를 했다가 다시 실행해야 하는 불편함이 있어서 nodemon을 사용한다.
- `nodemon server.js` 를 사용하면 내용을 저장할 때마다 서버가 알아서 재실행된다.

### __dirname

```jsx
const express = require("express");
const app = express();
const port = 3000;

app.get("/", (req, res) => {
  res.sendfile(__dirname + "/index.html");   // 현재 폴더가 어디인지와 상관없이 __dirname 사용
});

app.listen(port, function () {
  console.log(`server is running on port ${port}`);
});
```

```jsx
<form action="/" method="post">   // action에 적힌 곳으로 안의 내용을 보내준다.
      <input type="text" name="num1" placeholder="First Number" />
      <input type="text" name="num2" placeholder="Second Number" />
      <button type="submit" name="submit">Calculate</button>
</form>
```

# BMI 계산기

```html
<body>
	<h1>BMI</h1>
    <form action="/bmi.html" method="post">
      <input type="text" name="height" placeholder="height" />  <!-- name값이 가져올 값이 된다. -->
      <input type="text" name="weight" placeholder="weight" />
      <button type="submit" name="submit">Calculate BMI</button> <!-- submit이 아닌 일반 버튼이면 작동하지 않는다. -->
    </form>
</body>
```

```jsx
const express = require("express");
const bodyParser = require("body-parser");

const app = express();
app.use(bodyParser.urlencoded({ extended: true }));
const port = 3000;

app.get("/bmi.html", function (req, res) {
  res.sendfile(__dirname + "/bmi.html");    // 원하는 파일을 가져와서 띄움
}); 

app.post("/bmi.html", function (req, res) {
  let height = parseFloat(res.body.height); // form에 입력된 값을 가져와서 변수에 담는다.
  let weight = parseFloat(res.body.weight);

  let bmi = weight / ((height / 100) * (height / 100));
  let result = bmi.toFixed(1);

  res.send(`Your BMI is ${result}`);   // bmi 결과를 보내준다.
});

app.listen(port, function () {
  console.log(`server is running on port ${port}`);
});
```

---

# API (Application Programming Interface)

- 웹사이트에 날씨에 대한 모듈을 배치하고 싶을 때 우리가 직접 풍속과 기온을 계산해서 표시하는 것이 아닌, 그러한 모듈을 제공해주는 것을 가져오는데 그 제공받는 것이 API이다.
- 명령, 함수, 프로토콜의 집합
- 프로그래머가 소프트웨어를 만들거나 외부 시스템과 상호 작용하는 데에 사용할 수 있는 개체
- 내 서버에서 다른 서버에서 요청하고 가져오는 것
- 날씨API,  친구목록 API 등

### path와 endpoint, query로 API를 사용하고 원하는 부분을 특정할 수 있다.

[`https://samples.openweathermap.org/data/2.5/weather?q=London,uk&appid=439d4b804bc8187953eb36d2a8c26a02`](https://samples.openweathermap.org/data/2.5/weather?q=London,uk&appid=439d4b804bc8187953eb36d2a8c26a02) 

- 이러한 샘플 API키가 있다고 하면 `weather` 까지가 endpoint이고, 그 뒤는 query를 통해서 api의 범위를 특정짓고 있는 것이다.

### openWeatherMap API 사용하기

- [https://samples.openweathermap.org/data/2.5/weather?q=London,uk&appid=439d4b804bc8187953eb36d2a8c26a02](https://samples.openweathermap.org/data/2.5/weather?q=London,uk&appid=439d4b804bc8187953eb36d2a8c26a02) 이러한 샘플 API가 있는데 들어가보고 잘뜬다.
- [https://api.openweathermap.org/data/2.5/weather?q=London,uk&appid=439d4b804bc8187953eb36d2a8c26a02](https://api.openweathermap.org/data/2.5/weather?q=London,uk&appid=439d4b804bc8187953eb36d2a8c26a02) 하지만 samples가 아닌 실제 api로 입력을 하면 invalid key 즉, 무효하다고 나오면서 날씨정보가 나오지 않는다.
api 키를 제대로 입력해주지 않았기 때문이다.
로그인을 해서 나의 api키를 복사해서 붙여넣어야 한다.
- [`api.openweathermap.org/data/2.5/weather?q=](http://api.openweathermap.org/data/2.5/weather?q=){city name}&appid={your api key}` 
정해진 형식에 맞춰서 입력을 해야한다. 하지만 현재는 `appid` 가 유효하지 않기 때문에 무효하다고 나오는 것이다. 뒷 부분의 내용을 지우고 나의 api key를 입력하니까 잘 출력된다.

```html
{"coord":{"lon":16.75,"lat":53.61},"weather":[{"id":803,"main":"Clouds",
"description":"broken clouds","icon":"04d"}],"base":"stations","main":
{"temp":299.98,"feels_like":298.6,"temp_min":298.15,"temp_max":300.93,
"pressure":1008,"humidity":40},"visibility":10000,"wind":{"speed":2.89,"deg":9},
"clouds":{"all":70},"dt":1597839165,"sys":{"type":3,"id":2000216,"country":"PL",
"sunrise":1597808389,"sunset":1597860818},"timezone":7200,"id":3083826,"name":
"Korea","cod":200}
```

- 이것이 현재 한국 날씨로 나온 값인데 온도(temp)를 보면 299.98 이라고 되어있는 것을 볼 수가 있다.
- openWeatherMap은 기본적으로 온도에 켈빈이라는 단위를 쓰는데 path의 query를 수정해서 섭씨로 수정할 수 있다. 본문을 읽어보면 섭씨로 표현하고자 한다면 `units=metric` 을 쿼리로 입력하라고 나온다.

```html
{"coord":{"lon":16.75,"lat":53.61},"weather":[{"id":803,"main":"Clouds",
"description":"broken clouds","icon":"04d"}],"base":"stations","main":
{"temp":27.02,"feels_like":26.98,"temp_min":25.56,"temp_max":27.78,
"pressure":1008,"humidity":39},"visibility":10000,"wind":{"speed":0.89,"deg":0,
"gust":6.71},"clouds":{"all":70},"dt":1597839430,"sys":{"type":3,"id":2000216,
"country":"PL","sunrise":1597808389,"sunset":1597860818},"timezone":7200,
"id":3083826,"name":"Korea","cod":200}
```

- path를 수정한 결과 온도(temp)가 섭씨로 잘 출력되는 것을 볼 수 있다.
- query의 순서 즉, city가 먼저 들어가고 단위를 설정하는 units가 들어가고 api key가 들어가고의 순서는 중요하지 않다. 순서에 달라져도 값은 똑같이 나온다. 하지만 각각의 키와 밸류 묶음 사이사이에 `앰퍼샌드(&)` 가 들어가는 것은 중요하다.

### postman

- 위와 같은 api들을 사용할 때의 path가 매우 길고 복잡해서 단순한 오타를 유발하기 쉽고 알아보기가 어렵다.
- 따라서 postman과 같은 프로그램을 사용해주는 것이 좋다.
- key와 value를 표로 구분해서 정리하고 요청해서 받을 수 있다.
- 결과값 또한 깔끔하게 정리되어 JSON 형식으로 돌려받는다.

### JSON(Javascript Object Notation)

- postman을 통해 돌려받는 데이터는 자바스크립트 객체를 생성하는 것과 흡사하다.
- 중괄호세트, 키, 콜론, 밸류, 쉼표 등
- JSON은 API를 받을 수 있는 유일한 값이 아니다. XML,HTML 등이 있지만 JSON이 가장 무게가 가볍기 때문에 선호되는 형식이다. 또한 자바스크립트 객체로 바꾸는 것이 매우 쉽다.

### API를 가져오는 과정

- 클라이언트가 우리 서버에 요청(GET)을 한다.
- 우리는 다시 다른 서버에 다시 데이터를 요청(GET)한다.
- 다른 서버에서 우리에게 응답을 준다.
- 우리도 그 데이터를 기반으로 클라이언트에게 응답을 준다.

```jsx
const express = require("express");
const https = require("https");     // https 모듈을 가져온다. node 내장이기 때문에 따로 설치가 필요없다.

const app = express();

app.get("/", function (req, res) {
  // API 경로를 가져온다
  const url = "https://api.openweathermap.org/data/2.5/weather?q=Korea&appid=c82c3f6c6bd33fc2c13a04ae34366a9c&units=metric";
  https.get(url, function (response) {
    console.log(response);              // 가져온 데이터를 콘솔에 찍어볼 수 있다.
  });

  res.send("server is running");
});

app.listen(3000, function () {
  console.log("server is running...");
});
```
