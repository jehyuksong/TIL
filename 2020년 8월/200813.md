# 오늘 한 일🔥

- 생활코딩 머신러닝 기초 코스 1일차 수업을 들었다.
- 생활코딩 머신러닝 중급 코스 1일차 수업을 들었다.

---

# 오늘 느낀 점🔥

- 머신러닝에 대한 개념을 알게 되어서 신난다.
- 콜백함수랑 생성자 함수에 대한 개념이 조금은 잡힌 것 같은 느낌?!

---

# 생활코딩 코딩야학 [머신러닝] - 기초코스 1일차

# 1-1. 오리엔테이션

- 문제가 크면 클수록 공부의 효율이 올라간다.
- 최소한의 공부로 문제를 해결하는 것이 매우 중요하다.

---

# 1-2. 머신러닝이란?

- 결정 = 비교 + 선택
- 무언가를 비교할 수 있다면 선택은 기계적인 일이다. 더 좋은 것을 선택할 수 있기 때문이다.
- 더 빠른 길, 더 값싼 물건 등을 알 수 있다면 선택은 전혀 어려움이 없다.
- 하지만 현실에서는 더 비싸지만 성능은 더 좋은 등 비교가 애매한 경우가 대부분이다.

### 숫자

- 비교를 명확하게 할 수 있는 혁명적인 발명
- 또한, 컴퓨터의 발명으로 결정이 좀 더 쉬워졌다.

### 머신러닝

- 포크레인이 있다고 손이 필요없어지는 것이 아니고, 자동차를 발명했다고 해서 발이 필요없어지는 게 아닌 것처럼 머신러닝은 우리의 판단능력을 확장해서 정확하고 빠르게 해주는 도구이다.

---

# 1-3. 꿈

- 해결하고자 하는 문제가 없다면 지식은 목적없는 수단에 불과하다.
- 이 수업에서는 안좋은 습관이라는 문제를 공유해서 해결해보자.

     ⇒ 손톱을 물어뜯는 습관을 고친다는 문제를 공유해보자.

- 습관을 해결하기 위해서는 의지만으로 부족하고, 환경을 바꿔야 한다.
- 그런데 그 환경을 바꾸는 것은 의지이다. 가위바위보 관계라고 할 수 있다.
- 머신러닝이 이런 환경을 만들어 줄 수 있을까?

---

# 1-4. 궁리하는 습관

- 더 좋은 머신러닝을 만들기 위해서는 원리, 수학, 코딩이 필요하지만 사용자가 되어 보는 것이 중요하다.
- 휴대폰의 제조방법을 알기보다는 사용자가 되어보는 것이 중요하다.
- 머신러닝으로 다양한 문제를 해결하다보면 한계를 느끼고 그 한계를 느낄 때 더 깊게 공부하는 것이다.
- 일 = 꿈 + 능력
- 꿈이 능력보다 큰 사람들은 몽상가로 치부되었지만, 현재 시대는 그 사람들이 혁명가가 될 수 있다.

### 구상

- 습관을 고치는 앱을 구상한다고 해보자.
- 손톱을 물어뜯는 것을 앱을 통해서 어떻게 고칠 수 있을까?
- 휴대폰을 깨물고 있는 사진과 깨물고 있지 않는 사진으로 기계를 학습시켜서 카메라를 통해 해결할 수 있을까?
- 전 세계에 많은 습관을 가진 사람들의 문제를 해결해줄 수 있지 않을까?
- 이 수업의 목적은 머신러닝이라는 도구를 이용할 궁리를 시작하는 것이다.

---

# 1-5. Teachable machine

- 수학과 코딩 없이도 머신러닝을 이용할 수 있고 머지 않아 누구나 머신러닝을 이용해서 기계를 학습시키고 활용할 수 있게 될 것이다.
- 컴퓨터가 초창기에는 일부 사람들의 소유물이었던 것처럼 머신러닝도 그렇게 될 것이다.
- Teachable machine은 누구나 머신러닝을 이용할 수 있게 만들어진 도구이다.
- 손톱을 깨물고 있는 습관 클래스 하나를 만들어서 여러 사진을 캡쳐하고, 손톱을 깨물지 않고 있는 정상 클래스 하나를 만들어서 여러 사진을 캡쳐한 뒤, 기계에게 학습을 시킨다.
- 그 뒤에 화면에서 내가 손톱을 깨물려고 손을 올리면 손톱의 퍼센트가 올라가고 손을 내리면 정상 클래스의 퍼센트가 올라간다.
- 더 많고 정확한 정보들이 많을 수록 정확도가 올라간다.

---

# 1-6. 모델

- 어떠한 현상을 보고 판단할 수 있는 판단력을 **모델**이라고 부른다.
- 또한, 이러한 모델을 만드는 과정을 **학습**이라고 부른다.
- 좋은 모델을 만들어야 좋은 추측을 할 수 있고, 좋은 결정을 할 수 있다.

# 오늘의 수업에서의 인상깊은 말

> 현재 우리는 꿈이 능력보다 훨씬 커도 몽상가가 아닌 혁명가로 불릴 수 있는 시대에 살고 있다.

> 신나고 설레는 것이 중요하다. 그것이 실력이다.

# 기초 1일차 느낀 것🔥

- 인공지능이라는 분야에 대해서 설레고 어떻게 활용하는 지가 원리와 깊은 분야보다 훨씬 중요하다는 생각이 든다.
- 내가 웹앱을 제대로 구현할 수 있을 때가 온다면 그때는 인공지능의 활용도가 올라가고, 접근성이 더 좋아져서 결국 활용도의 차이로 판가름이 날 것이다.

---

# 생활코딩 코딩야학 [머신러닝] - 중급코스 1일차

# 2-1. 오리엔테이션

- 오렌지는 코드 없이 드래그 앤 드롭으로 표의 분석, 시각화, 머신러닝 예측과 같이 중요한 작업을 쉽게 배우고 사용할 수 있는 도구이다.
- 오렌지는 표를 다루는 도구인데 표는 회계사들에 의해 억압적으로 만들어진 도구이다.
- 표에 데이터를 가둘 수 있다면 정리정돈이 가능하고 상상도 할 수 없는 많은 일들을 해낼 수 있다.
- 표 속에서 의미있는 통찰력을 끄집어내는 것은 쉽지 않은데 오렌지가 그것을 도와줄 것이다.

---

# 2-2. 시나리오와 전략

- 레몬에이드를 판매하는 사장님이라고 가정해보자.
- 오늘 레몬에이드가 몇 개가 팔릴지 예측하기가 어렵다.
- 그래서 일기예보를 통해 몇 개가 팔릴지 예측해보기로 하자.

### 정보기술의 본질

- 입력 → 처리 → 출력
- 오렌지도 이와 같은 원리로 돌아간다.

### 오렌지

- 표를 다루는 도구이고 데이터들을 어떻게 동적으로 다룰 지 배우고, 시각화를 통해 데이터의 특성을 파악하고, 그 데이터를 바탕으로 미래를 예측하고 현재에 대한 결정을 내릴 수 있어야 한다.
그 부분을 기계에게 맡기는 것이다.

---

# 2-3. 오렌지 설치

---

# 2-4. 기본 사용법

- 우선 우리는 어떠한 요소가 레몬에이드 판매량에 영향을 주는 것인지 알지 못한다고 가정한다.
- 데이터의 양은 많을수록 더욱 정확해진다.
- 위젯과 위젯들은 선으로 연결된다. (입력 - 처리 - 출력)

### 입력

- 표에 담긴 데이터들을 구글 스프레트시트 URL을 통해 오렌지에 입력해본다.
- File이라는 위젯이 오렌지로 들어온 인풋이다.

### 출력

- 파일에서 드래그를 하면 선이 생기고 위젯과 연결할 수 있다.
- Data Table에 연결하면 출력이 지정된다.

### 처리

- 처리에서 필터링이 매우 중요하다.
- 예를 들어, 판매량 44보다 적은 판매량만 보고 싶다고 한다면 File을 드래그해서 Select Rows - Data Table로 연결해주고 Select Rows 에서 판매량 44 isbelow(미만) 을 선택해준다.
- 출력인 Data Table에서 필터링한 것들만 표시가 된다.
- 처리가 된 데이터(Matching Data), 필터링되지 않은 데이터(Unmatched Data) 등 다양하게 설정해서 출력에 옵션을 줄 수 있다.

---

# 중급 1일차 느낀 것🔥

- **오렌지** 라는 프로그램을 통해서 꽤나 직관적으로 머신러닝에 대한 학습이 어떻게 이루어지고 데이터를 어떻게 처리하는 지에 대해서 경험해본 것이 흥미로웠다.

---

# DOM

- DOM을 이용해서 자바스크립트로 html와  css를 조작할 수 있다.

### innerHTML 과 textContent의 차이

```html
<h1><strong>Hello</strong></h1> 
```

- 위와 같은 html을 작성한 후에 아래와 같이 javascript로 가져온다.

```jsx
document.querySelector("h1").innerHTML;      // <strong>Hello</strong>
document.querySelector("h1").textContent;    // Hello
```

- `innerHTML`은 `h1` 의 내용을 전부 가져오지만,
`textContent` 는 `h1` 의 내용 중에서 텍스트만을 가져온다.

```jsx
document.querySelector("h1").innerHTML = "<em>oh my god!</em>";

// <h1><em>oh my god!</em></h1>
```

- 그렇기 때문에 `innerHTML`은 위처럼 태그도 함께 추가하는 것이 가능하다.
- `textContent` 로 똑같이 추가할 경우 `<em>` 태그의 이탤릭체가 적용되지 않고 <em></em> 둘다 문자열로 포함되어 인식된다.

### addEventListener

- 필요할 때 호출해서 사용되는 것

```jsx
document.querySelector("button").addEventListener("click", handleClick);
																					// 매개변수 2번째의 호출에서 () 를 쓰지 않는다.
function handleClick() {                  // () 를 붙이면 즉시 호출되어서 alert이 뜬다.
  alert("clicked");
}
```

### querySelectorAll

```jsx
let drums = document.querySelectorAll(".drum");
for (i = 0; i < drums.length; i++) {
  drums[i].addEventListener("click", handleClick);
}

function handleClick() {
  alert("clicked");
}
```

- querySeletorAll 은 단일 DOM 객체를 가져오는 것이 아니고 NodeCollection을 가져오는 것이다.
- 노드컬렉션은 숫자인덱스를 가지고 있고 length property를 가지고 있다..
- for와 forEach를 이용해 가져와서 사용하는 것도 하나의 방법이다.

```jsx
let drums = document.querySelectorAll(".drum");
drums.forEach(function (drum) {
  drum.addEventListener("click", handleClick);
});    

function handleClick() {
  alert("clicked");
}
      
 // forEach를 사용한 방법 , 위와 결과는 똑같다.
```

### 트리거

- addEventListener가 발생하면 두번째 매개변수에 있는 함수를 트리거한다.  클릭된 버튼이  trigger 되어서  this 를 통해 추적할 수 있는 것이다.

### keypress

```jsx
document.addEventListener("keypress", function () {
  let button = event.key;      // event.key 를 통해서 어떤 키가 눌렸는지 확인이 가능하다.
  switch (button) {
    case "w":
      let tom1 = new Audio("sounds/tom-1.mp3");
      tom1.play();
      break;

    case "a":
      let tom2 = new Audio("sounds/tom-2.mp3");
      tom2.play();
      break;

    case "s":
      let tom3 = new Audio("sounds/tom-3.mp3");
      tom3.play();
      break;

    case "d":
      let tom4 = new Audio("sounds/tom-4.mp3");
      tom4.play();
      break;

    case "j":
      let snare = new Audio("sounds/snare.mp3");
      snare.play();
      break;

    case "k":
      let crash = new Audio("sounds/crash.mp3");
      crash.play();
      break;

    case "l":
      let kick = new Audio("sounds/kick-bass.mp3");
      kick.play();
      break;

    default:
      console.log(button);
  }
}
```

- `keypress` 를 통해서 키보드로 연주를 구현할 수 있다.
- `event.key` 를 추적해서 어떤 키보드가 눌리는 지 확인 후에 마우스로 클릭할 때 처럼 switch 문으로 구현해준다.
