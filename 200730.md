# 오늘 한 일🔥

- 하루 3분 네트워크 5~8화 읽기
- 그림으로 개념을 이해하는 알고리즘 chapter 2 읽기
- 가볍게 jquery, gulp, babel 이 어떤 것인지 사용해봤다.
- 러닝 자바스크립트를 통해 공부를 했다!! (내일은 chapter 3.17 정규표현식부터 이어서 공부하면 됨)

---

# 네트워크

### 패킷 교환에서 필요한 것

- 컴퓨터
- 인터페이스
- 통신 매체
- 라우터(패킷 교환기)

### 컴퓨터 네트워크

- 컴퓨터에서 라우터(멀티액세스 네트워크), 라우터에서 라우터(포인트 투 포인트 네트워크), 라우터에서 컴퓨터의 방식으로 연결되어 있다.
- 이런 방식들이 조합되어서 네트워크 전체가 만들어진다.

### LAN(Local Area Network)

- 지역적으로 좁은 범위에서 본인이 책임지고 구축하는 네트워크
- 예를 들면 학교 강의실에 설치된 10대의 컴퓨터 네트워크
- 그 강의실의 LAN이 묶여서 대학이라는 큰 LAN이 된다.

### WAN(Wide Area Network)

- 통신사업자의 서비스를 통해 떨어져 있는 지역의 LAN을 연결한 네트워크
- 세계 최대 규모의 WAN은 인터넷이다.

### OSI 참조모델

- 데이터 통신을 7개의 단계로 나누는데 이 단계를 계층이라고 부른다.
- 제 7 계층 ] 응용계층 : 사용자에게 네트워크 서비스를 제공한다.
- 제 6 계층 ] 표현계층 : 데이터의 형식을 결정한다.
- 제 5 계층 ] 세션계층 : 데이터 송수신의 순서 등을 관리한다.
- 제 4 계층 ] 전송계층 : 신뢰성이 높은(에러가 적은) 전송을 시행한다.
- 제 3 계층 ] 네트워크계층 : 전송 규칙과 수신처를 결정한다.
- 제 2 계층 ] 데이터링크계층 : 인접기기 사이의 데이터 전송을 제어한다.
- 제 1 계층 ] 물리계층 : 전기, 기계적인 부분의 전송을 시행한다.

→ 데이터 통신을 할 때는 7계층에서 1계층으로, 각각의 순서를 단계쩍으로 수행함으로써 데이터 통신을 한다.

→ 네트워크에 의한 데이터 통신은 단계마다의 복수의 프로토콜로 실현된다.

→ 데이터를 수신하는 측에서는 1계층부터 7계층까지의 순서대로 데이터를 수신한다.

- **송신을 요구한다 > 7,6,5,4,3,2,1 계층 > 전송매체 > 1,2,3,4,5,6,7 계층 > 데이터를 수신한다.**
- 어떤 계층의 프로토콜 변경은 다른 계층에 영향을 끼치지 않는다. (계층이 각각 독립해 있다.)

 → 우편 배달원이 봍우와 편지지 그리고 안에 써있는 내용에 관여하지 않는 것과 같다.

### 프로토콜 데이터 유닛(PDU; Protocol Data Unit)

- 데이터에 통신에 필요한 데이터를 덧붙여서 통합된 상태
- 제어용 정보를 붙여서 통합됨.

### 캡슐화

- 계층의 순서대로 헤더가 부가되어가는 것
- 수신자 측에서는 반대의 순서로 헤더를 벗겨서 데이터를 입수한다.

### PDU 호칭

- 사용자 ] 데이터 : 송수신하고 싶은 데이터
- 7,6,5계층  PDU ] 메시지 : 데이터를 통신용으로 변환한 것과 7계층 헤더
- 4계층 PDU ] 세그먼트,데이터그램 : 메시지와 4계층 헤더
- 3계층 PDU ] 데이터그램 : 세그먼트, 데이터그램과 3계층 헤더
- 2계층 PDU ] 프레임 : 데이터그램과 2계층헤더(2계층 꼬리부)
- 1계층 ] 신호 : 프레임을 전송매체로 운반하기 위한 신호로 변환

---

# 알고리즘

### 배열과 리스트

- 여러 개의 항목을 저장하고 싶을 때는 배열이나 리스트를 사용한다.

### 배열

- 값이 연달아서 이웃하는 위치에 저장되기 때문에 값을 추가할 때 배열 전체가 움직여야 할수도 있다.
- 특정 값에 접근하기에 매우 용이하다.
- **임의접근이 가능하기 때문에 10번째 원소로 바로 건너뛸 수 있다.**
- 읽기 : $O(1)$, 삽입 : $O(n)$, 삭제 : $O(n)$ ; → 읽기가 빠르다.

### 리스트

- 리스트의 안의 값들이 여기저기 흩어져서 저장되지만 다음 주소를 찍어주기 때문에 값을 추가할 때 기존 원소들의 움직임 없이 바로 추가할 수 있다.
- 특정 값에만 접근을 하려면 그 값에 도달하기 전까지 가야 주소를 알 수 있기 때문에 적합하지가 않다.
- **순차 접근만 가능하기 때문에 10번째 원소를 읽으려면 9개 원소를 모두 읽어서 링크를 찾아내야 한다.**
- 읽기 :  $O(n)$, 삽입 :  $O(1)$, 삭제 : $O(1)$ ; → 삽입과 삭제가 빠르다.

### 선택 정렬

- 실행 시간 : $O(n^2)$

```jsx
function selectionSort(array) {
  for (let i = 0; i < array.length; i++) {
    let minIndex = i;
    for (let j = i + 1; j < array.length; j++) {
      if (array[minIndex] > array[j]) {
        minIndex = j;
      }
    }
    if (minIndex !== i) {
      let swap = array[minIndex];
      array[minIndex] = array[i];
      array[i] = swap;
    }
    console.log(`${i}회전: ${array}`);
  }
  return array;
}
console.log(selectionSort([5, 4, 3, 2, 1]));

// 0회전: 1,4,3,2,5
// 1회전: 1,2,3,4,5
// 2회전: 1,2,3,4,5
// 3회전: 1,2,3,4,5
// 4회전: 1,2,3,4,5
// (5) [1, 2, 3, 4, 5]
```

- 최소값을 정해놓고 더 작은 값을 찾으면 그 값을 최소값으로 놓고 기존 값의 앞에 놓는 것을 반복한다.

---

### let

- 변수 선언은 선언단계,초기화단계,할당단계가 있는데 선언과 초기화가 동시에 일어나는 var와 달리 let은 독립적으로 일어난다.

```jsx
// 스코프의 선두에서 선언 단계가 실행된다.
// 아직 변수가 초기화(메모리 공간 확보와 undefined로 초기화)되지 않았다.
// 따라서 변수 선언문 이전에 변수를 참조할 수 없다.
console.log(foo); // ReferenceError: foo is not defined

let foo; // 변수 선언문에서 초기화 단계가 실행된다.
console.log(foo); // undefined

foo = 1; // 할당문에서 할당 단계가 실행된다.
console.log(foo); // 1
```

```jsx
let foo = 1; // 전역 변수

{
  console.log(foo); // ReferenceError: foo is not defined
  let foo = 2; // 지역 변수
}
```

- ES6의 선언문도 여전히 호이스팅이 발생하기 때문에 참조 에러(ReferenceError)가 발생한다. 
ES6의 let으로 선언된 변수는 블록 레벨 스코프를 가지므로 코드 블록 내에서 선언된 변수 foo는 지역 변수이다. 따라서 지역 변수 foo도 해당 스코프에서 호이스팅되고 코드 블록의 선두부터 초기화가 이루어지는 지점까지 일시적 사각지대(TDZ)에 빠진다. 따라서 전역 변수 foo의 값이 출력되지 않고 참조 에러(ReferenceError)가 발생한다.

### Rest

- Rest 파라미터(Rest Parameter, 나머지 매개변수)는 매개변수 이름 앞에 세개의 점 `...`을 붙여서 정의한 매개변수를 의미한다. Rest 파라미터는 함수에 전달된 인수들의 목록을 배열로 전달받는다.

```jsx
function rest(...rest) {
  console.log(rest);
}

rest(1, 2, 3, 4, 5, 6, 7);   // [1,2,3,4,5,6,7]
```

```jsx
function foo(param, ...rest) {
  console.log(param); // 1
  console.log(rest);  // [ 2, 3, 4, 5 ]
}

foo(1, 2, 3, 4, 5);

function bar(param1, param2, ...rest) {
  console.log(param1); // 1
  console.log(param2); // 2
  console.log(rest);   // [ 3, 4, 5 ]
}

bar(1, 2, 3, 4, 5);
```

- 함수에 전달된 매개변수들은 순차적으로 파라미터와 rest파라미터에 할당된다.

```jsx
function foo(...rest) {}
console.log(foo.length); // 0

function bar(x, ...rest) {}
console.log(bar.length); // 1

function baz(x, y, ...rest) {}
console.log(baz.length); // 2
```

- Rest 파라미터는 함수 정의 시 선언한 매개변수 개수를 나타내는 함수 객체의 length 프로퍼티에 영향을 주지 않는다.

---

### 사용자 입력은 항상 비동기적이라는 사실에 익숙해져야 한다.

- 사용자의 입력에 따라 일어나는 이벤트는 사용자의 마음대로 언제 클릭할지, 클릭을 할지 말지 정해진다.

### 걸프(Gulp)

- 반복적인 개발 작업을 자동화하는 빌드 도구.
- 그런트(Grunt)도 널리 쓰인다.

### 바벨(Babel)

- ES6 코드를 ES5 코드로 변환하는 트랜스컴파일러이다.

### ES린트(ESLint)

- 자주 하는 실수를 피하고 더 나은 프로그래머가 되도록 돕는 린트 프로그램이다.

### 에버그린 브라우저

- 항상 최신 버전을 유지할 수 있게 업그레이드를 거부할 수 없게 하는 브라우저

### Symbol은 new 키워드와 함께 사용하지 않는다.

- 대문자로 시작하는 식별자는 new와 함께 쓴다는 불문율의 예외임을 기억하자!

### 객체는 언제나 같은 것을 가르킨다. 그 안의 프로퍼티들이 바뀔 뿐.

- 객체는 원시타입이 아니다.
- 원시타입 ⇒ 문자열, 숫자열, null, undefined, boolean, Symbol

### 변수는 다른 변수끼리도 값이 같으면 같은 메모리(같은 주소)를 가르키지만, 객체는 다른 객체의 프로퍼티가 서로 같다고 하더라도 다른 메모리(다른 주소)를 가르키고 그 주소가 같은 값을 가르키고 있는 것이다.

### 날짜

- 자바스크립트에서는 날짜와 시간이 내장된 Date 객체를 사용한다.

```jsx
console.log(new Date());

// 2020-07-30T12:56:11.056Z          (현재 날짜)
```

```jsx
console.log(new Date(2020, 9, 30));

// 2020-10-29T15:00:00.000Z          (날짜 지정)
```

```jsx
console.log(new Date(2020, 9, 30, 19, 30));
 
// 2020-10-30T10:30:00.000Z          (날짜, 시간 지정)
```

- 이외에도 getMonth(),getDate(),getDay(),getHours() 등등 매우 많다.
