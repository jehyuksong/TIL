# 오늘 한 일🔥

- 인터넷 자료들을 통해서 자바스크립트 공부를 했다.
- `하루 3분 네트워크` 라는 책과 `그림으로 개념을 이해하는 알고리즘` 이라는 책을 읽기 시작했다.
2권을 매일 조금씩 읽어서 11일동안 다 읽을 수 있게 나눠놨다!
다 읽을 때까지 책 읽는 시간과 자바스크립트 공부 시간을 분배해서 할 것이다!

---

# 사고하는 방향

- 0과 1밖에 모르는 컴퓨터를 위해서 컴퓨터적으로 사고하고, 작게 분해해서 생각하는 것을 연습하자!
- 내가 쓰는 코드의 동작을 예측할 수 없이 복사,붙여넣기를 하는 것을 절대 안된다.

# 흐름제어

- 문(statement)은 일반적으로 위에서 아래로 순서대로 실행된다.
이러한 실행 순서는 조건문(`if`, `switch`)이나 반복문(`while`, `for`)의 사용으로 제어할 수 있다.
이를 흐름제어(Control Flow)라 한다. 
또는 함수 호출로 변경될 수 있다.

# prototype (프로토타입)

- 함수를 만들 때는 기본적으로 `prototype`과 `constructor`가 만들어진다.

```jsx
function person() {}

console.log(person.prototype);

/* {constructor: ƒ}
   constructor: ƒ person()
   __proto__: Object */
```

```jsx
function Person() {}

Person.prototype.eyes = 2;
Person.prototype.nose = 1;

const jehyuk = new Person();
const seunghyun = new Person();

console.log(jehyuk.eyes);
console.log(seunghyun.nose);
```

- Prototype Object는 일반적인 객체이므로 속성을 마음대로 추가/삭제 할 수 있다.
jehyuk과 seunghyun은 함수를 통해 생성되었기 때문에 `Person.prototype` 을 참조할 수 있다.

```jsx
function Person() {}

Person.prototype.eyes = 2;
Person.prototype.nose = 1;

const jehyuk = new Person();
const seunghyun = new Person();

console.log(jehyuk);

/*  Person {}
     __proto__:
      eyes: 2
      nose: 1
     constructor: ƒ Person()
     __proto__: Object  */
```

- `prototype` 속성은 함수만 가지고 있던 것과는 달리 `__proto__` 속성은 모든 객체가 빠짐없이 가지고 있는 속성이다.
- `__proto__`는 객체가 생성될 때 조상이었던 함수의 `Prototype Object`를 가리킨다. jehyuk객체는 Person 함수로부터 생성되었으니 Person 함수의 `Prototype Object`를 가리키고 있는 것이다.
- jehyuk 객체가 eyes를 직접 가지고 있지 않기 때문에 eyes 속성을 찾을 때 까지 상위 prototype을 탐색하고, 최상위인 Object의 Prototype Object까지 도달했는데도 못찾았을 경우 `undefined` 를 리턴한다. 이렇게 `__proto__`속성을 통해 상위 `prototype`과 연결되어있는 형태를 프로토타입 체인(Prototype Chain)이라고 합니다.

# 프로그래밍이란

- **프로그래밍**은 `변수`를 통해 값을 저장하고 참조하며 `연산자`로 값을 연산, 평가하고 `조건문과 반복문`에 의한 흐름제어로 데이터의 흐름을 제어하고 `함수`로 재사용이 가능한 구문의 집합을 만들며 `객체, 배열` 등으로 자료를 구조화하는 것이다.

# 데이터 타입의 특징

- 자바스크립트에서는 모든 수를 정수가 아닌 실수로 처리한다.
- 문자열은 원시타입이다.

```jsx
var str = 'Hello';
str = 'world';
```

- 첫번째 구문이 실행되면 메모리에 문자열 'Hello'가 생성되고 식별자 str은 메모리에 생성된 문자열 'Hello'의 메모리 주소를 가리킨다. 그리고 두번째 구문이 실행되면 이전에 생성된 문자열 'Hello'을 수정하는 것이 아니라 새로운 문자열 'world'를 메모리에 생성하고 식별자 str은 이것을 가리킨다. 
이때 문자열 'Hello'와 'world'는 모두 메모리에 존재하고 있다. 
변수 str은 문자열 'Hello'를 가리키고 있다가 문자열 'world'를 가리키도록 변경되었을 뿐이다.

```jsx
var str = 'string';
// 문자열은 유사배열이다.
for (var i = 0; i < str.length; i++) {
  console.log(str[i]);
}

// 문자열을 변경할 수 없다.
str[0] = 'S';
console.log(str); // string
```

→ 문자열은 배열처럼 인덱스를 통해 접근할 수 있다. 이와 같은 특성을 갖는 데이터를 **유사 배열**이라 한다.

`str[0] = 'S'`처럼 이미 생성된 문자열의 일부 문자를 변경해도 반영되지 않는다(이때 에러가 발생하지 않는다). 한번 생성된 문자열은 read only로서 변경할 수 없다. 이것을 변경 불가능(immutable)이라 한다.

그러나 새로운 문자열을 재할당하는 것은 물론 가능하다. 이는 기존 문자열을 변경하는 것이 아니라 새로운 문자열을 새롭게 할당하는 것이기 때문이다.

---

# 네트워크

- 무언가(점)와 무언가(점)가 그물망처럼 무언가(선)에 의해 연결되어있어, 연결과 주고받기를 하는 것

### 컴퓨터 네트워크

- 컴퓨터와 컴퓨터가 그물망처럼 통신 매체로 연결되어서 데이트를 운반하는 것
- 리소스를 유용하게 활용하기 위해 공유할 수 있다.

### 리소스

- 컴퓨터나 사용자가 가진 물리적, 논리적을 따지지 않는 '자원'
- 리소스를 공유함으로써 한 대로는 불가능했던 일이 가능해진다. 
ex) 프린터기를 같이 사용, 정보교환, 홈페이지 공유 등

### 데이터

- 컴퓨터상에서의 리소스를 공유하기 위한 정보
- 비트(bit)라는 단위로 표현되는데 비트는 '0'이나 '1'인 상태를 유지할 수 있다.
- 2진수로 간주해 숫자로 표시하는 방식이 자주 사용됨.

### 데이터 통신

- 네트워크를 실행할 수 있게 해주는 방법
- 데이터 통신에서는 컴퓨터, 통신 매체, 인터페이스가 필요하다.
- 컴퓨터와 통신 매체를 중개하는 것이 인터페이스이다.

### 프로토콜

- 데이터 통신상에서의 규칙, 보내는 쪽과 받는 쪽이 사용하는 규칙
- 예를 들어, '가'를 '000001'로 보냈으면 받는 쪽에서도 '000001'로 받아야 하기 때문에 존재한다.

### 회선 교환

- 교환기를 사용해서 파이프를 교체해가는 방식
ex) 전화기는 교환기랑만 연결되어 있고 교환기에 의해 상대한테 파이프가 연결되게 하는 것.
- 회선이 점유되면 더 이상 접속되지 않아서 동시에 다수의 컴퓨터가 송수신할 수 없다는 문제점이 있다.

### 패킷 교환

- 데이터를 패킷으로 분할해서 송신하기 때문에 회선이 점유되지 않아서 다수의 기기가 동시에 사용할 수 있다.
- 각각의 수신처가 붙어있어서 패킷이 섞여도 각 수신처에 도달한다.
- **그래서 컴퓨터 네트워크는 패킷 교환 방식을 사용한다.**

---

# 알고리즘

```jsx
1부터 100까지의 숫자 중에서 하나를 찾아야하는 경우
```

### 단순 탐색

- 1부터 2,3,4,5,6 ... 찾아나가는 것
- 바보 같은 탐색법이다.

### 이진 탐색

- 그 숫자의 중간을 택하며 찾아가는 것. 50, 75, 63... 이런식으로 찾아간다.
- 단계마다 절반의 숫자를 없앨 수 있다.
- 1~100일 경우 어떤 숫자가 답이 되든지 최대 7번 만에 정답을 맞출 수 있다.
- 리스트의 원소들이 정렬되어 있어야만 사용할 수 있다.

```jsx
let arr = [];

for (i = 0; i <= 1000; i++) {
  arr.push(i);
}

function binarySearch(target, dataArr) {
  let index = 0;

  let low = 0;
  let high = dataArr[dataArr.length - 1];

  while (low <= high) {
    let mid = Math.floor((low + high) / 2);
    let guess = dataArr[mid];

    if (guess == target) {
      return guess;
    } else if (guess > target) {
      high = mid - 1;
    } else {
      low = mid + 1;
    }
    index++;
    console.log(
      `${index}. low: ${low}, mid: ${mid}, high: ${high}, data: ${dataArr[mid]}`
    );
  }
  return undefined;
}

let result = binarySearch(1000, arr);
console.log(result);

/* 1. low: 501, mid: 500, high: 1000, data: 500
   2. low: 751, mid: 750, high: 1000, data: 750
   3. low: 876, mid: 875, high: 1000, data: 875
   4. low: 939, mid: 938, high: 1000, data: 938
   5. low: 970, mid: 969, high: 1000, data: 969
   6. low: 986, mid: 985, high: 1000, data: 985
   7. low: 994, mid: 993, high: 1000, data: 993
   8. low: 998, mid: 997, high: 1000, data: 997
   9. low: 1000, mid: 999, high: 1000, data: 999
   1000   */
```

- 자바스크립트로 이진 탐색을 구현한 것이다.

### 선형 시간

- 단순 탐색을 하면 40억 개의 원소에서 최대 40억 번의 추측을 해야한다. 이것을 선형 시간이라고 한다.

### 로그 시간

- 이진 탐색에서는 40억 개의 원소라고 해도 최대 32번만 추측하면 맞출 수 있다. 이런 경우를 로그 시간으로 실행된다고 한다.
- 이진 탐색과 단순 탐색의 속도 차이는 원소의 개수가 늘어날수록 어마어마하게 차이가 난다.
- 리스트의 원소가 10억 개 있다면 속도는 3300만배가 차이난다.

### 빅오 표기법

- 알고리즘이 얼마나 빠른지 표시하는 특별한 방법
- 리스트의 크기가 n이라고 가정했을 때 단순 탐색의 빅오 표기법에 따른 실행 시간은 O(n)
- 이진 탐색의 실행 시간은 O(log n)이다.

 → 앞에서는 big 0 라서 O를 쓰고  괄호 안에는 연산횟수가 들어간다.

- 혹여나 찾는 숫자 1이라고 단순 탐색으로 한번에 찾았다고 하더라도 실행 시간은 O(1)이 아니라 O(n) 시간이다.
- 리스트의 크기가 100이고 한번의 연산을 하는데에 0.1초가 걸린다고 가정하면 
→ 단순 탐색의 경우 O(100) , 실행 시간은 10초이고,
→ 이진 탐색의 경우 O(log100), 실행 시간은 0.664초가 걸린다.
- 

### 기억할 것

- **알고리즘의 속도는 시간이 아니라 연산 횟수가 어떻게 증가하는 지로 측정한다**
- **알고리즘의 실행 시간은 어떻게 증가하는가로 측정하고, 빅오 표기법으로 나타낸다.**
- **입력 데이터의 크기가 늘어날 때 알고리즘의 실행 속도가 얼마나 증가하는지 알 수 있다.**
